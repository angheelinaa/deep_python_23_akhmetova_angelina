# Домашнее задание #01 (введение, тестирование)

### 1. Функция оценки сообщения
Реализовать функцию predict_message_mood, которая приниамает на вход строку, экземпляр модели SomeModel и пороги хорошести.
Функция возвращает:
- "неуд", если предсказание модели меньше bad_threshold
- "отл", если предсказание модели больше good_threshold
- "норм" в остальных случаях

```py
class SomeModel:
    def predict(self, message: str) -> float:
        # реализация не важна


def predict_message_mood(
    message: str,
    model: SomeModel,
    bad_thresholds: float = 0.3,
    good_thresholds: float = 0.8,
) -> str:
    ...


assert predict_message_mood("Чапаев и пустота", model) == "отл"
assert predict_message_mood("Вулкан", model) == "неуд"
```

### 2. Генератор для чтения и фильтрации файла
Есть текстовый файл, который может не помещаться в память.
В каждой строке файла фраза или предложение: набор слов, разделенных пробелами (знаков препинания нет).

Генератор должен принимать на вход имя файла или файловый объект и список слов для поиска.
Генератор перебирает строки файла и возвращает только те из них (строку целиком), где встретилось хотя бы одно из слов для поиска.
Поиск должен выполняться по полному совпадению слова без учета регистра.

Например, для строки из файла "а Роза упала на лапу Азора" слово поиска "роза" должно найтись, а "роз" или "розан" - уже нет.

### 3. Тесты в отдельном модуле для каждого пункта

### 4. Перед отправкой на проверку код должен быть прогнан через flake8 и pylint, по желанию еще black

### 5. Покрытие тестов через coverage, отчет в репу


# Домашнее задание #02

### Написать функцию, которая в качестве аргументов принимает строку json, список полей, которые необходимо обработать, список имён, которые нужно найти и функцию-обработчика имени, который срабатывает, когда в каком-либо поле было найдено ключевое имя.

Функция, должна принимать строку, в которой содержится json, и произвести парсинг этого json.
Упростим немного и представим, что json представляет из себя только коллекцию ключей-значений.
Причём ключами и значениями являются только строки.

```py
def parse_json(json_str: str, required_fields=None, keywords=None, keyword_callback)
```

Например, представим, что json_str = '{"key1": "Word1 word2", "key2": "word2 word3"}', а required_fields = ["key1"], keywords = ["word2"]. Тогда keyword_callback будет вызвана только для слова 'word2' для ключа 'key1'.

Распарсить json можно так:
```py
import json

...
json_doc = json.loads(json_str)

```

Можно использовать ещё ujson, но его предварительно нужно установить с помощью pip.

### Написать декоратор, который выводит среднее время выполнения последних k вызовов при каждом вызове функции

```py
@mean(10)
def foo(arg1):
    pass

@mean(2)
def boo(arg1):
    pass

for _ in range(100):
    foo("Walter")
```

### Использовать mock-объект при тестировании
Использовать mock-объект, например, keyword_callback и проверить, что заглушка вызывалась n число раз.

### Узнать степень покрытия тестами с помощью библиотеки coverage

### Использовать flake8 и pylint для проверки кода

### Использовать factory boy (опционально!!!)
Для генерации данных и ключевых слов, можно использовать factory boy (см. файл factory_boy_example.py).


# Домашнее задание #03 (объектная модель, ООП)

### 1. Реализовать класс CustomList наследованием от list

При этом:
- CustomList должен наследоваться от встроенного списка `list`;
- экземпляры CustomList можно складывать друг с другом и с обычными списками:
  ```py
  CustomList([5, 1, 3, 7]) + CustomList([1, 2, 7])  # CustomList([6, 3, 10, 7])
  CustomList([1]) + [2, 5]  # CustomList([3, 5])
  [2, 5] + CustomList([1])  # CustomList([3, 5])
  ```
- экземпляры CustomList поддерживают вычитание между собой и с обычными списками:
  ```py
  CustomList([5, 1, 3, 7]) - CustomList([1, 2, 7])  # CustomList([4, -1, -4, 7])
  CustomList([1]) - [2, 5]  # CustomList([-1, -5])
  [2, 5] - CustomList([1])  # CustomList([1, 5])
  ```
- результатом сложения/вычитания должен быть новый кастомный список;
- при сложении/вычитании списков разной длины отсутствующие элементы меньшего списка считаются нулями;
- при сложения/вычитания исходные списки должны оставаться неизменными;
- при сравнении (==, !=, >, >=, <, <=) экземпляров CustomList должна сравниваться сумма элементов списков (сравнение с list не нужно);
- должен быть переопределен str, чтобы выводились элементы списка и их сумма;
- списки можно считать всегда числовыми.

### 2. Тесты CustomList в отдельном модуле

### 3. Перед отправкой на проверку код должен быть прогнан через flake8 и pylint, по желанию еще black


# Домашнее задание #04 (дескрипторы, метаклассы, ABC)

### 1. Метакласс, который в начале названий всех атрибутов и методов, кроме магических, добавляет префикс "custom_"
  Подменяться должны атрибуты класса и атрибуты экземпляра класса, в том числе добавленные после выполнения конструктора (dynamic в примере).

```py
    class CustomMeta(...):
        pass


    class CustomClass(metaclass=CustomMeta):
        x = 50

        def __init__(self, val=99):
            self.val = val

        def line(self):
            return 100

        def __str__(self):
            return "Custom_by_metaclass"


    assert CustomClass.custom_x == 50
    CustomClass.x  # ошибка

    inst = CustomClass()
    assert inst.custom_x == 50
    assert inst.custom_val == 99
    assert inst.custom_line() == 100
    assert str(inst) == "Custom_by_metaclass"

    inst.x  # ошибка
    inst.val  # ошибка
    inst.line() # ошибка
    inst.yyy  # ошибка

    inst.dynamic = "added later"
    assert inst.custom_dynamic == "added later"
    inst.dynamic  # ошибка
```


### 2. Дескрипторы с проверками типов и значений данных
  Нужно сделать три дескриптора для какой-то области интереса (наука, финансы, хобби и тд), но если совсем не получается, то можно использовать шаблона ниже в качестве основы.

```py
    class Integer:
        pass

    class String:
        pass

    class PositiveInteger:
        pass

    class Data:
        num = Integer()
        name = String()
        price = PositiveInteger()

        def __init__(...):
            ....
```


### 3. Тесты метакласса и дескрипторов

### 4. Перед отправкой на проверку код должен быть прогнан через flake8 и pylint, по желанию еще black


# Домашнее задание #05 (стандартная библиотека)

### 1. LRU-кэш
Интерфейс:

```py
    class LRUCache:

        def __init__(self, limit=42):
            pass

        def get(self, key):
            pass

        def set(self, key, value):
            pass


    cache = LRUCache(2)

    cache.set("k1", "val1")
    cache.set("k2", "val2")

    assert cache.get("k3") is None
    assert cache.get("k2") == "val2"
    assert cache.get("k1") == "val1"

    cache.set("k3", "val3")

    assert cache.get("k3") == "val3"
    assert cache.get("k2") is None
    assert cache.get("k1") == "val1"


    Если удобнее, get/set можно сделать по аналогии с dict:
    cache["k1"] = "val1"
    print(cache["k3"])
```

Сложность решения по времени в среднем должна быть константной O(1).
Реализация любым способом без использования OrderedDict.

### 2. Тесты в отдельном модуле


# Домашнее задание #06 (потоки, процессы)

### 1. Клиент-серверное приложение для обкачки набора урлов с ограничением нагрузки
#### Cервер
master-worker cервер для обработки запросов от клиента.

Алгоритм должен быть следующим:

    - Сервер должен поддерживать взаимодействие с любым числом клиентов;
    - Мастер и воркеры это разные потоки в едином приложении сервера;
    - Количество воркеров задается при запуске;
    - Мастер слушает порт, на который клиенты будут по TCP отправлять урлы для обкачки;
    - Мастер принимает запроc и передает его одному из воркеров;
    - Воркер читает url от клиента;
    - Воркер обкачивает url по http и возвращает клиенту топ K самых частых слов и их частоту в формате json {"word1": 10, "word2": 5};
    - После каждого обработанного урла сервер должен вывести статистику: сколько урлов было обработано на данный момент суммарно всеми воркерами;

`python server.py -w 10 -k 7` (сервер использует 10 воркеров для обкачки и отправляет клиенту топ-7 частых слов)

#### Клиент
Утилита, отправляющая запросы с урлами серверу по TCP в несколько потоков.
Нужно сделать следующее:

    - Подготовить файл с запросами (порядка 100 разных url);
    - На вход клиенту передаётся два аргумента --- файл с URL'ами и количество потоков M;
    - Клиент создает M потоков, отправляет запросы на сервер в каждом потоке и печатает ответ сервера в стандартый вывод, например: `xxx.com: {'word1': 100, 'word2': 50}`.

`python client.py 10 urls.txt`


Все действия должны быть выделены в классы/функции.

### 2. Тесты в отдельном модуле


# Домашнее задание #07 (async)

### 1. Скрипт для асинхронной обкачки урлов
Написать скрипт для обкачки списка урлов с возможностью задавать количество одновременных запросов, используя асинхронное программирование.
Клиент можно использовать любой, например, из aiohttp.
Например, 10 одновременных запросов могут задаваться командой:

`python fetcher.py -c 10 urls.txt`
или
`python fetcher.py 10 urls.txt`

### 2. Тесты в отдельном модуле


# Домашнее задание #08 (память, профилирование)

### 1. Сравнение использования weakref и слотов
Нужно придумать свои типы с несколькими атрибутами:
- класс с обычными атрибутами
- класс со слотами
- класс с атрибутами weakref

Для каждого класса создается большое число экземпляров и замеряется (сравнивается):
- время создания пачки экземпляров
- время чтения/изменения атрибутов

Результаты замеров оформляются скриншотами c описанием и выводом.

### 2. Профилирование
Провести профилирование вызовов и памяти для кода из пункта 1.

Результаты оформляются скриншотами c описанием.

### 3. Декоратор для профилирования
Применение декоратора к функции должно выполнять прoфилирование (cProfile) всех вызовов данной функции.
Вызов метода `.print_stat()` должен выводить единую таблицу со статистикой профилирования суммарно по всем вызовам функции.


```py
def profile_deco(...):
    ...


@profile_deco
def add(a, b):
    return a + b


@profile_deco
def sub(a, b):
    return a - b


add(1, 2)
add(4, 5)
sub(4, 5)


add.print_stat()  # выводится результат профилирования суммарно по всем вызовам функции add (всего два вызова)
sub.print_stat()  # выводится результат профилирования суммарно по всем вызовам функции sub (всего один вызов)
```


# Домашнее задание #09 (логирование)

### 1. Логирование LRUCache

- Нужно добавить логирование разного уровня в файл cache.log.
- По аргументу командной строки "-s" дополнительно логировать в stdout с отдельным форматированием.
- По аргументу командной строки "-f" нужно применять кастомный фильтр, например, отбрасывающий записи c четным числом слов или что-то свое.
- "-s" и "-f" могут указываеться в одном запуске и должны работать вместе в таком случае (модуль argparse).

Логирование должно покрывать как минимум следующие случаи:
- get существующего ключа
- get отсутствующего ключа
- set отсутствующего ключа
- set отсутствующего ключа, когда достигнута ёмкость
- set существующего ключа
- различные debug записи в дополнение и в зависимости от реализации

При запуске модуля должны выполняться все перечисленные операции с кэшом (через функцию в `if __name__ == "__main__"`).

Код решения должен быть целиком в каталоге данного ДЗ без ссылок/импортов на домашки про LRUCache.
Корректность LRUCache в данном задании не проверяется.

### 2. Перед отправкой на проверку код должен быть прогнан через flake8 и pylint, по желанию еще black



