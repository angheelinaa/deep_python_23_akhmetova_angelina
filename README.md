# Домашнее задание #01 (введение, тестирование)

### 1. Функция оценки сообщения
Реализовать функцию predict_message_mood, которая приниамает на вход строку, экземпляр модели SomeModel и пороги хорошести.
Функция возвращает:
- "неуд", если предсказание модели меньше bad_threshold
- "отл", если предсказание модели больше good_threshold
- "норм" в остальных случаях

```py
class SomeModel:
    def predict(self, message: str) -> float:
        # реализация не важна


def predict_message_mood(
    message: str,
    model: SomeModel,
    bad_thresholds: float = 0.3,
    good_thresholds: float = 0.8,
) -> str:
    ...


assert predict_message_mood("Чапаев и пустота", model) == "отл"
assert predict_message_mood("Вулкан", model) == "неуд"
```

### 2. Генератор для чтения и фильтрации файла
Есть текстовый файл, который может не помещаться в память.
В каждой строке файла фраза или предложение: набор слов, разделенных пробелами (знаков препинания нет).

Генератор должен принимать на вход имя файла или файловый объект и список слов для поиска.
Генератор перебирает строки файла и возвращает только те из них (строку целиком), где встретилось хотя бы одно из слов для поиска.
Поиск должен выполняться по полному совпадению слова без учета регистра.

Например, для строки из файла "а Роза упала на лапу Азора" слово поиска "роза" должно найтись, а "роз" или "розан" - уже нет.


# Домашнее задание #02

### Написать функцию, которая в качестве аргументов принимает строку json, список полей, которые необходимо обработать, список имён, которые нужно найти и функцию-обработчика имени, который срабатывает, когда в каком-либо поле было найдено ключевое имя.

Функция, должна принимать строку, в которой содержится json, и произвести парсинг этого json.
Упростим немного и представим, что json представляет из себя только коллекцию ключей-значений.
Причём ключами и значениями являются только строки.

```py
def parse_json(json_str: str, required_fields=None, keywords=None, keyword_callback)
```

Например, представим, что json_str = '{"key1": "Word1 word2", "key2": "word2 word3"}', а required_fields = ["key1"], keywords = ["word2"]. Тогда keyword_callback будет вызвана только для слова 'word2' для ключа 'key1'.

Распарсить json можно так:
```py
import json

...
json_doc = json.loads(json_str)

```

Можно использовать ещё ujson, но его предварительно нужно установить с помощью pip.

### Написать декоратор, который выводит среднее время выполнения последних k вызовов при каждом вызове функции

```py
@mean(10)
def foo(arg1):
    pass

@mean(2)
def boo(arg1):
    pass

for _ in range(100):
    foo("Walter")
```

### Использовать mock-объект при тестировании
Использовать mock-объект, например, keyword_callback и проверить, что заглушка вызывалась n число раз.

### Узнать степень покрытия тестами с помощью библиотеки coverage

### Использовать flake8 и pylint для проверки кода

### Использовать factory boy (опционально!!!)
Для генерации данных и ключевых слов, можно использовать factory boy (см. файл factory_boy_example.py).
