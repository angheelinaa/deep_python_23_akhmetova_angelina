# Домашнее задание #01 (введение, тестирование)

### 1. Функция оценки сообщения
Реализовать функцию predict_message_mood, которая приниамает на вход строку, экземпляр модели SomeModel и пороги хорошести.
Функция возвращает:
- "неуд", если предсказание модели меньше bad_threshold
- "отл", если предсказание модели больше good_threshold
- "норм" в остальных случаях

```py
class SomeModel:
    def predict(self, message: str) -> float:
        # реализация не важна


def predict_message_mood(
    message: str,
    model: SomeModel,
    bad_thresholds: float = 0.3,
    good_thresholds: float = 0.8,
) -> str:
    ...


assert predict_message_mood("Чапаев и пустота", model) == "отл"
assert predict_message_mood("Вулкан", model) == "неуд"
```

### 2. Генератор для чтения и фильтрации файла
Есть текстовый файл, который может не помещаться в память.
В каждой строке файла фраза или предложение: набор слов, разделенных пробелами (знаков препинания нет).

Генератор должен принимать на вход имя файла или файловый объект и список слов для поиска.
Генератор перебирает строки файла и возвращает только те из них (строку целиком), где встретилось хотя бы одно из слов для поиска.
Поиск должен выполняться по полному совпадению слова без учета регистра.

Например, для строки из файла "а Роза упала на лапу Азора" слово поиска "роза" должно найтись, а "роз" или "розан" - уже нет.

### 3. Тесты в отдельном модуле для каждого пункта

### 4. Перед отправкой на проверку код должен быть прогнан через flake8 и pylint, по желанию еще black

### 5. Покрытие тестов через coverage, отчет в репу


# Домашнее задание #02

### Написать функцию, которая в качестве аргументов принимает строку json, список полей, которые необходимо обработать, список имён, которые нужно найти и функцию-обработчика имени, который срабатывает, когда в каком-либо поле было найдено ключевое имя.

Функция, должна принимать строку, в которой содержится json, и произвести парсинг этого json.
Упростим немного и представим, что json представляет из себя только коллекцию ключей-значений.
Причём ключами и значениями являются только строки.

```py
def parse_json(json_str: str, required_fields=None, keywords=None, keyword_callback)
```

Например, представим, что json_str = '{"key1": "Word1 word2", "key2": "word2 word3"}', а required_fields = ["key1"], keywords = ["word2"]. Тогда keyword_callback будет вызвана только для слова 'word2' для ключа 'key1'.

Распарсить json можно так:
```py
import json

...
json_doc = json.loads(json_str)

```

Можно использовать ещё ujson, но его предварительно нужно установить с помощью pip.

### Написать декоратор, который выводит среднее время выполнения последних k вызовов при каждом вызове функции

```py
@mean(10)
def foo(arg1):
    pass

@mean(2)
def boo(arg1):
    pass

for _ in range(100):
    foo("Walter")
```

### Использовать mock-объект при тестировании
Использовать mock-объект, например, keyword_callback и проверить, что заглушка вызывалась n число раз.

### Узнать степень покрытия тестами с помощью библиотеки coverage

### Использовать flake8 и pylint для проверки кода

### Использовать factory boy (опционально!!!)
Для генерации данных и ключевых слов, можно использовать factory boy (см. файл factory_boy_example.py).


# Домашнее задание #03 (объектная модель, ООП)

### 1. Реализовать класс CustomList наследованием от list

При этом:
- CustomList должен наследоваться от встроенного списка `list`;
- экземпляры CustomList можно складывать друг с другом и с обычными списками:
  ```py
  CustomList([5, 1, 3, 7]) + CustomList([1, 2, 7])  # CustomList([6, 3, 10, 7])
  CustomList([1]) + [2, 5]  # CustomList([3, 5])
  [2, 5] + CustomList([1])  # CustomList([3, 5])
  ```
- экземпляры CustomList поддерживают вычитание между собой и с обычными списками:
  ```py
  CustomList([5, 1, 3, 7]) - CustomList([1, 2, 7])  # CustomList([4, -1, -4, 7])
  CustomList([1]) - [2, 5]  # CustomList([-1, -5])
  [2, 5] - CustomList([1])  # CustomList([1, 5])
  ```
- результатом сложения/вычитания должен быть новый кастомный список;
- при сложении/вычитании списков разной длины отсутствующие элементы меньшего списка считаются нулями;
- при сложения/вычитания исходные списки должны оставаться неизменными;
- при сравнении (==, !=, >, >=, <, <=) экземпляров CustomList должна сравниваться сумма элементов списков (сравнение с list не нужно);
- должен быть переопределен str, чтобы выводились элементы списка и их сумма;
- списки можно считать всегда числовыми.

### 2. Тесты CustomList в отдельном модуле

### 3. Перед отправкой на проверку код должен быть прогнан через flake8 и pylint, по желанию еще black

